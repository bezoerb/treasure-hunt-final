---
import "../styles/global.css";
import streetsRaw from "../../data/streets.geojson?raw";
import borderRaw from "../../data/border.geojson?raw";

const streets = JSON.parse(streetsRaw);
const border = JSON.parse(borderRaw);

const title = "Karte";
const MAPBOX_TOKEN = import.meta.env.PUBLIC_MAPBOX_TOKEN;
// Centralized, tweakable constants
const CONFIG = {
  DEFAULT_REVEAL_DURATION_MS: 2 * 60 * 60 * 1000, // 2 hours
  MAX_RADIUS_METERS: 120, // starting street buffer radius
  MIN_RADIUS_METERS: 6,   // final point buffer radius
  BORDER_INSET_METERS: 2, // shrink border a touch to avoid edge bleed
  LATE_SPLIT_THRESHOLD: 0.9, // force split late in time
  STREET_FADE_START: 0.6,
  STREET_FADE_END: 0.95,
  STREET_BASE_MULT: 0.02,
  STREET_PROGRESS_MULT: 0.6,
  // Minimum street width (meters). Streets stop shrinking once they reach this.
  STREET_MIN_WIDTH_METERS:  7,
  LENGTH_FADE_START: 0.2,
  LENGTH_FADE_END: 1,
  LENGTH_INFLUENCE_METERS: 500,
  // Duration of the final fade/taper (fraction of total reveal time)
  LATE_TAPER: 0.06,
  // Reveal points only near the end (fraction of total progress)
  POINT_REVEAL_START: 0.94
};
---

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"
    />
    <title>{title}</title>
    <link href="https://api.mapbox.com/mapbox-gl-js/v3.13.0/mapbox-gl.css" rel="stylesheet">
    <script defer src="https://api.mapbox.com/mapbox-gl-js/v3.13.0/mapbox-gl.js"></script>
  </head>
  <body class="min-h-screen">
    <main class="min-h-screen">
      <div id="map" data-token={MAPBOX_TOKEN} class="w-full h-[100dvh]"></div>
    </main>

    <script id="streets-data" type="application/json" set:html={JSON.stringify(streets)}></script>
    <script id="border-data" type="application/json" set:html={JSON.stringify(border)}></script>
    <script id="config" type="application/json" set:html={JSON.stringify(CONFIG)}></script>
    <script type="module">
      import * as turf from 'https://cdn.skypack.dev/@turf/turf';
      import polygonClipping from 'https://cdn.skypack.dev/polygon-clipping';
      function init() {
        const container = document.getElementById('map');
        const token = container?.dataset?.token || '';
        if (!token) {
          console.error('PUBLIC_MAPBOX_TOKEN is missing. Set it in your environment.');
          return;
        }

        const jsonEl = document.getElementById('streets-data');
        const borderEl = document.getElementById('border-data');
        const cfgEl = document.getElementById('config');
        if (!jsonEl || !borderEl || !cfgEl) return;
        const streetsJson = JSON.parse(jsonEl.textContent || '{}');
        const borderJson = JSON.parse(borderEl.textContent || '{}');
        const CFG = JSON.parse(cfgEl.textContent || '{}');

        // @ts-ignore - mapboxgl is provided globally by the CDN script
        if (!window.mapboxgl) {
          console.error('Mapbox GL JS failed to load');
          return;
        }

        // @ts-ignore
        mapboxgl.accessToken = token;
        // @ts-ignore
        const map = new mapboxgl.Map({
          container: 'map',
          style: 'mapbox://styles/mapbox/streets-v12',
          center: [10.0, 51.0],
          zoom: 4
        });

        // @ts-ignore
        map.addControl(new mapboxgl.NavigationControl(), 'top-right');

        map.on('load', () => {
          // Data is a mix of LineString (streets) and Point (places)

          // Border/mask source (for visualization and clipping)
          map.addSource('border', {
            type: 'geojson',
            data: borderJson
          });

          // Clip layer approach didn't work reliably, switching back to turf.mask for guaranteed clipping

          // No precise point markers â€” keep the locations hidden

          // Build dynamic hint from streets and points
          map.addSource('hint', {
            type: 'geojson',
            data: {
              type: 'FeatureCollection',
              features: []
            }
          });

          map.addLayer({
            id: 'hint-fill',
            type: 'fill',
            source: 'hint',
            paint: {
              'fill-color': '#ff5500',
              'fill-opacity': 0.4
            }
          });
          map.addLayer({
            id: 'hint-outline',
            type: 'line',
            source: 'hint',
            paint: {
              'line-color': '#ff5500',
              'line-width': 2,
              'line-opacity': 0.7
            }
          });

          // Draw border for context
          map.addLayer({
            id: 'border-outline',
            type: 'line',
            source: 'border',
            paint: {
              'line-color': '#4b5563',
              'line-width': 2,
              'line-opacity': 0
            }
          });

          // Time-based: from a persistent start timestamp
          const STORAGE_KEY = 'treasure-hunt:startTs';
          // Default duration (2h). Override via URL: ?dur=60000 or ?dur=1m or 30s. Reset via ?reset=1
          function parseDuration(input) {
            if (!input) return null;
            const n = Number(input);
            if (!Number.isNaN(n)) return n; // milliseconds
            const m = String(input).trim().match(/^(\d+)(ms|s|m|h)$/i);
            if (!m) return null;
            const value = Number(m[1]);
            const unit = m[2].toLowerCase();
            switch (unit) {
              case 'ms': return value;
              case 's': return value * 1000;
              case 'm': return value * 60 * 1000;
              case 'h': return value * 60 * 60 * 1000;
              default: return null;
            }
          }
          const url = new URL(window.location.href);
          if (url.searchParams.get('reset') === '1') {
            localStorage.removeItem(STORAGE_KEY);
          }
          const override = parseDuration(url.searchParams.get('dur'));
          const REVEAL_DURATION_MS = override ?? (CFG.DEFAULT_REVEAL_DURATION_MS ?? 2 * 60 * 60 * 1000);
          const MAX_RADIUS_METERS = CFG.MAX_RADIUS_METERS ?? 120;
          const MIN_RADIUS_METERS = CFG.MIN_RADIUS_METERS ?? 6;

          let startTs = Number(localStorage.getItem(STORAGE_KEY) || 0);
          if (!startTs) {
            startTs = Date.now();
            localStorage.setItem(STORAGE_KEY, String(startTs));
          }

          function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

          function currentRadiusMeters(nowTs) {
            const elapsed = nowTs - startTs;
            const progress = clamp(elapsed / REVEAL_DURATION_MS, 0, 1);
            // Ease-out to reveal slower at first, faster later
            const eased = 1 - Math.pow(1 - progress, 2);
            // Two-phase reveal: start with street-only buffer, then split toward points
            // We map eased [0,1] to a radius that shrinks to point-level near the end
            const radius = MAX_RADIUS_METERS - (MAX_RADIUS_METERS - MIN_RADIUS_METERS) * eased;
            return { radius: Math.max(radius, 0), progress };
          }

          function splitStreetsAndPoints(fc) {
            const streets = [];
            const points = [];
            for (const f of (fc.features || [])) {
              const t = f?.geometry?.type;
              if (t === 'LineString') streets.push(f);
              else if (t === 'Point') points.push(f);
            }
            return { streets, points };
          }

          function smoothstep(edge0, edge1, x) {
            const t = clamp((x - edge0) / (edge1 - edge0), 0, 1);
            return t * t * (3 - 2 * t);
          }

          function buildBuffers(radiusMeters, progress) {
            if (!streetsJson?.features?.length || radiusMeters <= 0) {
              return { type: 'FeatureCollection', features: [] };
            }
            const km = radiusMeters / 1000;
            const polygons = [];
            const { streets, points } = splitStreetsAndPoints(streetsJson);
            // Shrink street influence to 0 near the end
            const streetWeight = 1 - smoothstep(CFG.STREET_FADE_START ?? 0.6, CFG.STREET_FADE_END ?? 0.95, progress);
            let streetKm = km * ((CFG.STREET_BASE_MULT ?? 0.9) + (CFG.STREET_PROGRESS_MULT ?? 0.6) * (1 - progress)) * streetWeight;
            // Enforce a minimum street width so it stops shrinking visually
            const minStreetKm = (CFG.STREET_MIN_WIDTH_METERS ?? (2 * MIN_RADIUS_METERS)) / 1000;
            // Smoothly taper to zero near the end to avoid a pop
            const LFS = CFG.LENGTH_FADE_START ?? 0.75;
            const LFE = CFG.LENGTH_FADE_END ?? 1.0;
            const taper = CFG.LATE_TAPER ?? 0.05;
            if (progress >= LFE - taper) {
              const local = (progress - (LFE - taper)) / taper; // 0..1 in taper
              // Ease-in to zero width
              const ease = local * local;
              streetKm = minStreetKm * (1 - ease);
            } else {
              streetKm = Math.max(streetKm, minStreetKm);
            }
            if (progress >= LFE) streetKm = 0;
            // Length collapse by slicing each LineString toward nearest points
            const keepWeight = smoothstep(LFS, LFE, progress); // 0 -> 1 late
            const baseKeep = CFG.LENGTH_INFLUENCE_METERS ?? 300; // meters
            const keepHalfKm = ((MIN_RADIUS_METERS) + baseKeep * (1 - keepWeight)) / 1000; // half-window

            function mergeIntervals(ranges) {
              if (!ranges.length) return [];
              ranges.sort((a,b)=>a[0]-b[0]);
              const merged=[ranges[0].slice()];
              for (let i=1;i<ranges.length;i++){
                const [s,e]=ranges[i];
                const last=merged[merged.length-1];
                if (s<=last[1]) last[1]=Math.max(last[1],e); else merged.push([s,e]);
              }
              return merged;
            }

            if (streetKm > 0) {
              for (const s of streets) {
                const lineLenKm = turf.length(s, { units: 'kilometers' });
                // Gather along-line measures of nearby points
                const measures = [];
                for (const p of points) {
                  const distKm = turf.pointToLineDistance(p, s, { units: 'kilometers' });
                  if (distKm <= (streetKm + (MIN_RADIUS_METERS/1000))) {
                    const snapped = turf.nearestPointOnLine(s, p, { units: 'kilometers' });
                    const m = snapped?.properties?.location;
                    if (typeof m === 'number' && m >= 0 && m <= lineLenKm) measures.push(m);
                  }
                }
                let intervals = [];
                if (measures.length && progress >= LFS) {
                  for (const m of measures) {
                    const start = Math.max(0, m - keepHalfKm);
                    const end = Math.min(lineLenKm, m + keepHalfKm);
                    intervals.push([start, end]);
                  }
                } else {
                  intervals = [[0, lineLenKm]]; // early phase keep whole line
                }
                intervals = mergeIntervals(intervals);
                // Within the taper phase, also shrink interval lengths toward zero
                const taperFactor = progress >= (LFE - taper) ? (1 - Math.pow((progress - (LFE - taper)) / taper, 2)) : 1;
                for (let [startKm, endKm] of intervals) {
                  if (taperFactor < 1) {
                    const mid = (startKm + endKm) / 2;
                    const half = (endKm - startKm) / 2 * taperFactor;
                    startKm = Math.max(0, mid - half);
                    endKm = Math.min(lineLenKm, mid + half);
                  }
                  const slice = turf.lineSliceAlong(s, startKm, endKm, { units: 'kilometers' });
                  if (!slice || slice.geometry.coordinates.length < 2) continue;
                  const sbuf = turf.buffer(slice, streetKm, { units: 'kilometers' });
                  if (sbuf) polygons.push(sbuf);
                }
              }
            }
            // Points keep constant size (no scaling) but are hidden until near the end
            const minPointKm = MIN_RADIUS_METERS / 1000;
            const pointKm = minPointKm;
            if (progress >= (CFG.POINT_REVEAL_START ?? 0.94)) {
              for (const p of points) {
                const buf = turf.buffer(p, pointKm, { units: 'kilometers' });
                if (buf) polygons.push(buf);
              }
            }
            return turf.featureCollection(polygons);
          }

          function safeUnion(a, b) {
            try { return turf.union(a, b); } catch (_e) {}
            try { return turf.union(b, a); } catch (_e2) {}
            try { return turf.union(normalizePolygon(a), normalizePolygon(b)); } catch (_e3) {}
            try { return turf.union(turf.buffer(a, 0.5, { units: 'meters' }), b); } catch (_e4) {}
            try { return turf.union(a, turf.buffer(b, 0.5, { units: 'meters' })); } catch (_e5) {}
            return null;
          }

          function dissolveCollection(fc) {
            if (!fc?.features?.length) return { type: 'FeatureCollection', features: [] };
            // First try turf.dissolve directly
            try {
              const dissolved = turf.dissolve(fc);
              if (dissolved?.features?.length) return dissolved;
            } catch (_ignored) {}

            // Fallback: iterative union merge
            const pool = fc.features.map(f => normalizePolygon(f));
            const result = [];
            while (pool.length) {
              let current = pool.pop();
              let mergedThisRound = false;
              for (let i = 0; i < result.length; i++) {
                const u = safeUnion(result[i], current);
                if (u) {
                  result[i] = normalizePolygon(u);
                  mergedThisRound = true;
                  break;
                }
              }
              if (!mergedThisRound) result.push(current);
            }
            return { type: 'FeatureCollection', features: result };
          }

          // Get border feature for clipping
          function getBorderFeature() {
            if (!borderJson?.features?.length) return null;
            // Find the first polygon/multipolygon
            const borderFeature = borderJson.features.find(f => {
              const t = f?.geometry?.type;
              return t === 'Polygon' || t === 'MultiPolygon';
            });
            return borderFeature || null;
          }

          const borderFeature = getBorderFeature();
          const BORDER_INSET_METERS = CFG.BORDER_INSET_METERS ?? 2; // safety margin: shrink border slightly to avoid edge bleed

          function normalizePolygon(feature) {
            try {
              const inset = (feature === borderFeature && BORDER_INSET_METERS > 0) ? -BORDER_INSET_METERS : 0;
              const fixed = turf.buffer(feature, inset, { units: 'meters' });
              return fixed || feature;
            } catch (_e) {
              return feature;
            }
          }

          // Robust intersection using polygon-clipping
          function toPC(feature) {
            const g = feature.type === 'Feature' ? feature.geometry : feature;
            if (!g) return [];
            if (g.type === 'Polygon') return [g.coordinates];
            if (g.type === 'MultiPolygon') return g.coordinates;
            return [];
          }

          function pcToFC(mp) {
            if (!mp || !mp.length) return { type: 'FeatureCollection', features: [] };
            const features = [];
            for (const poly of mp) {
              if (poly && poly.length) {
                features.push(turf.polygon(poly));
              }
            }
            return { type: 'FeatureCollection', features };
          }

          function clipToBorder(buffersFc) {
            if (!borderFeature || !buffersFc?.features?.length) return buffersFc;
            try {
              const borderFixed = normalizePolygon(borderFeature);
              const borderPC = toPC(borderFixed);
              const clippedPieces = [];
              for (const piece of buffersFc.features) {
                const pieceFixed = normalizePolygon(piece);
                const piecePC = toPC(pieceFixed);
                if (!piecePC.length) continue;
                const out = polygonClipping.intersection(borderPC, piecePC);
                const fc = pcToFC(out);
                if (fc.features.length) clippedPieces.push(...fc.features);
              }
              return { type: 'FeatureCollection', features: clippedPieces };
            } catch (e) {
              console.warn('Clipping failed:', e);
              return buffersFc;
            }
          }

          function updateHintFrame() {
            const now = Date.now();
            const { radius, progress } = currentRadiusMeters(now);
            const pieces = buildBuffers(radius, progress);
            let unioned = dissolveCollection(pieces);
            // Late phase forced split disabled: length collapse handles revealing points
            const clipped = clipToBorder(unioned);
            const data = clipped?.features?.length ? clipped : unioned;
            const src = map.getSource('hint');
            if (src) src.setData(data);
            // Optional: reveal point markers at the very end if we add them later
            if (now - startTs < REVEAL_DURATION_MS) {
              requestAnimationFrame(updateHintFrame);
            }
          }

          // Kick off animation loop (smoother than setInterval and keeps in sync with tab focus)
          updateHintFrame();

          try {
            // Fit to data bounds if any features exist
            // @ts-ignore
            const bounds = new mapboxgl.LngLatBounds();
            if (streetsJson?.features?.length) {
              for (const f of streetsJson.features) {
                const t = f?.geometry?.type;
                if (t === 'Point') bounds.extend(f.geometry.coordinates);
                if (t === 'LineString') {
                  for (const c of f.geometry.coordinates) bounds.extend(c);
                }
              }
              if (!bounds.isEmpty()) {
                map.fitBounds(bounds, { padding: 40, duration: 800 });
              }
            }
          } catch (e) {
            console.warn('Could not fit bounds:', e);
          }
        });
      }

      if (document.readyState === 'complete') {
        init();
      } else {
        window.addEventListener('load', init);
      }
    </script>
  </body>
</html>

